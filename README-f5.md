### 类的加载、连接和初始化
#### JVM和类
+ `当调用java命令运行某个java程序时，该命令将会启动一个Java虚拟机进程`；`不管该java程序有多么复杂，该程序启动了多少个线程，他们都处于该java虚拟机进程里`；`同一个JVM的所有线程、所有变量都处于同一个进程中，他们都使用该JVM进程的内存区`，`当系统出现以下几种情况时，JVM进程将被终止`：`两次运行Java程序处于两个不同的JVM中，两个JVM之间并不会共享数据`；

|情况|
|------|
|`程序运行到最后正常结束`|
|`程序运行到使用System.exit()或Runtime.getRuntime().exit()代码处结束程序`|
|`程序执行过程中遇到未捕获的异常或错误而结束`|
|`程序所在平台强制结束了JVM进程`|

#### 类的加载

+ `当程序主动使用某个类时，如果该类还未被加载到内存，则系统会通过加载，连接，初始化三个步骤来对该类进行初始化`，`如果没有意外，JVM将会连续完成这三个步骤，所以有时把这三个步骤统称为类加载或类初始化`；`类加载指的是将类的class文件读入内存，并为之创建一个java.lang.Class对象`，`也就是说，当程序中使用任何类时，系统都会为之创建一个java.lang.Class对象`；`因为系统java.lang.Class对象中的所有的类实际上也是一个实例，他们都是java.lang.Class的实例`； `类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供了这些类加载器通常被称为系统类加载器`；`除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器`；

|通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源|
|------|
|`从本地系统加载class文件，这是前面绝大多数的类加载方式`|
|`从JAR包加载class文件`|
|`通过网络加载class文件`|
|`把一个java源文件动态编译，并执行加载`|

+ `类加载器通常无需等到”首先使用“该类时才加载该类，java虚拟机规范允许系统预先加载某些类`；

#### 类的连接

+ `当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中`；类连接又可分为如下三个阶段：

|阶段|说明|
|------|------|
|`验证`|`验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致`|
|`准备`|`类准备阶段则负责为类的类变量分配内存，并设置默认初始值`|
|`解析`|`将类的二进制数据中的符号引用替换成直接引用`|

#### 类的初始化

+ `在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对类变量进行初始化`，`在java类中对类变量指定初始值有两种方式`：`声明类变量时指定初始化`；`使用静态代码块为类变量指定初始值`；

|JVM初始化一个类包含如下几个步骤|
|------|
|`假如这个类还没有被加载和连接，则程序先加载并连接该类`|
|`假如该类的直接父类还没有被初始化，则先初始化其直接父类`|
|`假如类中有初始化语句，则系统依次执行这些初始化语句`|

#### 类初始化的时机

|当java程序首次通过下面6种方式来使用某个类或接口时，系统就会初始化该类或接口|
|-------|
|`创建类的实例，为某个类创建实例的方式包括：使用new关键字来创建实例，通过反射来创建实例，通过反序列化来创建实例`|
|`调用某个类的类方法（静态方法）`|
|`访问某个类或接口的类变量，或为该类变量赋值`|
|`通过反射方式来强制创建某个类或接口对应的java.lang.Class对象，例如代码：Class.forName("Persion")；如果系统还未初始化Person类，则这行代码将会导致该Person类被初始化，并返回Person类对应的java.lang.Class对象`|
|`初始化某个类的子类，当初始化某个类的子类时，该子类的父类都会被初始化`|
|`直接使用java.exe命令来运行某个类，当运行某个类时，程序会先初始化该主类`|

+ 除此之外，下面的几种情况需要特别指出：

|情况|
|------|
|`对于一个final型的类变量，如果该类变量的值在编译时就可以确定下来，那么这个类变量相当于宏变量`，`java编译器会在编译时直接把这个类变量出现的地方替换成它的值，因此即使程序使用该静态类变量，也不会导致该类的初始化`|
|`反之，如果final修饰的类变量的值在编译时不能确定下来，则必须等到运行时才可以确定该类变量的值，如果通过该类来访问该类变量，则会导致该类被初始化`|
|`当使用ClassLoader类的loadClass()方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化，使用Class的forName()方法才会导致强制初始化该类`|

#### Java中的引用

|引用|说明|
|------|------|
|`强引用`|垃圾回收机制不会回收，Java默认引用都是强引用|
|`软引用`|SoftReference在内存不够时，垃圾回收机制会考虑回收|
|`弱引用`|WeakReference在内存不够时，垃圾回收机制会优先回收|
|`虚引用`|PhantomReference在内存不够时，垃圾回收机制最优先回收|
