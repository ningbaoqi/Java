### 线程同步
#### 同步代码块
+ java的多线程支持引入了·同步监视器·来解决代码同步安全的问题，使用同步监视器的通用方法就是·同步代码块·，同步代码块的语法格式如下：

```
synchronized(obj){
       //需要在同步代码块中的代码
}
```

+ 上面的语法格式中`synchoronized后括号里的obj就是同步监视器`，上面代码的含义是：`线程开始执行同步代码块之前，必须先获得对同步监视器的锁定；任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对该同步监视器的锁定`；虽然java程序允许使用任何对象作为同步监视器，但想一下同步监视器的目的：`阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源充当同步监视器`；任何线程在修改指定资源之前，首先对该资源加锁，在加锁期间其他线程无法修改该资源，当该线程修改完成后，该线程释放对该资源的锁定，通过这种方式就可以保证并发线程在任意时刻只有一个线程可以进入修改共享资源的代码区（也被称为临界区），所以同一时刻最多只有一个线程处于临界区内，从而保证了线程的安全；

#### 同步方法
+ java的多线程安全支持还提供了同步方法，`同步方法就是使用synchoronized关键字来修饰某个方法`，则该方法被称为`同步方法`，对于`synchoronized修饰的实例方法（非static方法）`而言，`无须显式制定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象`；

|通过使用同步方法可以方便的实现线程安全的类，线程安全的类具有如下特性|
|------|
|该类的对象可以被多个线程安全的访问|
|每个线程调用该方法的任意方法之后都能得到正确结果|
|每个线程调用该对象的任意方法后，该对象状态依然保持合理状态|

```
public synchronized void draw(){}
```

+ `synchoronized关键字可以修饰方法、可以修饰代码块，但不能修饰构造器、成员变量等`；

|可变类的线程安全是以降低程序的运行效率作为代价，为了减少线程安全所带来的负面影响，程序可以采用如下策略|
|------|
|不要对线程安全类的所有方法都进行同步，只对那些会改变竞争资源（竞争资源也就是共享资源）的方法进行同步|
|如果可变类有两种运行环境，单线程环境和多线程环境，则应该为该可变类提供两个版本，即线程不安全版本和线程安全版本；在单线程环境中使用线程不安全版本以保证性能，在多线程环境中使用线程安全版本|

+ JDK所提供的`StringBuilder、StringBuffer`就是为了照顾单线程和多线程环境所提供的类；在`单线程环境下应该使用StringBuilder`来保证较好的性能，当`需要保证多线程安全时，应该使用StringBuffer`；

#### 释放同步监视器的锁定

+ 任何线程进入同步代码块、同步方法之前，必须先获得对同步监视器的锁定，那么何时会释放对同步监视器的锁定呢?

|程序无法显式释放对同步监视器的锁定，线程会在如下情况下释放对同步监视器的锁定|
|------|
|当前线程的同步方法、同步代码块执行结束，当前线程即释放同步监视器|
|当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行，当前线程将会释放同步监视器|
|当前线程在同步代码块、同步方法中出现了未处理的Error、Exception，导致该代码块、方法异常结束时，当前线程将会释放同步监视器|
|当前线程执行同步代码块、同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器|

##### 如下情况，线程不会释放同步监视器：

+ `执行同步代码块、同步方法时，程序调用Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器`；`线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放同步监视器`，当然，`程序应该尽量避免使用suspend()和resume()方法来控制线程`；

#### 同步锁lock

+ java提供了一种功能更强大的线程同步机制---通过`显式定义同步锁对象来实现同步`，在这种机制下，同步锁由`Lock对象`充当；`Lock`是控制多个线程对共享资源进行访问的工具，通常，锁提供了对共享对象的独占访问，`每次只能有一个线程对Lock对象加锁`，`线程开始访问共享资源之前应先获得Lock对象`，某些锁可能允许对共享资源并发访问，如ReadWriteLock读写锁；Lock、ReadWriteLock是java5提供的两个根接口，并为Lock提供了ReentrantLock可重入锁实现类，为ReadWriteLock提供了ReentrantReadWriteLock实现类；在实现线程安全的控制中，比较常用的是ReentrantLock可重入锁，使用该Lock对象可以显式的加锁、释放锁，通常使用ReentrantLock的代码格式为：

```
class X{
       //定义锁对象
       private final ReentrantLock lock = new ReentrantLock();
       //定义需要保证线程安全的方法
       public void m(){
              //加锁
              lock.lock();
              try{
                     //do something
              }.......{
                    //do something
              }finally{
                     //解锁
                     lock.unlock();
              }
       }
}
```

+ `ReentrantLock锁具有可重入性，也就是说，一个线程可以对已被加锁的ReentrantLock锁再次加锁`，`ReentrantLock对象会维持一个计数器来追踪lock()方法的嵌套调用`，`线程在每次调用lock()方法加锁后，必须显式调用unlock()方法释放锁，所以一段被锁保护的代码可以调用另一个被相同锁保护的方法`；

#### 死锁
+ 当两个线程互相等待对方释放同步监视器时就会发生死锁，导致所有线程处于阻塞状态，无法继续；
