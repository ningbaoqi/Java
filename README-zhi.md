### 对象、引用、指针
```
Person p = new Person()；
```
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-20.jpg) 
+ 可以让多个引用来引用这个对象；如果堆内存里的对象没有任何引用指向该对象，那么程序就无法再访问该对象，这个对象也就变成了垃圾，java的垃圾回收机制就会将这个对象回收，释放该对象所占的内存；因此，如果希望通知垃圾回收机制回收某个对象，只需要将该引用赋值为`null`即可；
### 对象的this引用
+ `this`关键字总是指向调用该方法的对象；根据this出现的位置的不同，this作为对象的默认引用有两个情况：构造器中引用该构造器正在初始化的对象；在方法中引用调用该方法的对象；`this`可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，它所代表的是当前类的实例，只有当这个方法被调用时，它所代表的对象才能被确定下来；谁在调用这个方法，this就代表谁；大部分时候，一个方法访问该类中定义的其他方法、成员变量时加不加this前缀的效果是一样的，对于static修饰的方法而言，则可以使用类来直接调用该方法，如果在static修饰的方法中使用this关键字，则这个关键字就无法指定合适的对象，所以，static修饰的方法中不能使用this关键字，静态成员不能直接访问非静态成员；
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-21.jpg) 
+ 如果需要在静态方法中访问另一个普通方法，则只能通过对象来调用；
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-22.jpg) 
+ this引用也可以用于构造器中作为默认引用，由于构造器是直接使用new关键字来调用，而不是使用对象来调用，所以this在构造器中代表该构造器正在初始化的对象：如下：在构造器中有一个与成员变量同名的局部变量，又必须在构造器中访问这个被覆盖的成员变量，必须使用this前缀；
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-23.jpg) 
+ 抽象类的构造器不能用于创建实例，主要是用于被其子类调用;子类继承了父类，将获得父类的全部成员变量和方法，但是Java的子类不能获得父类的构造器;子类构造器执行体中既没有super调用，也没有this调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器;不管使用哪种情况，当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行;当创建Java对象时，系统总是先调用该类里定义的初始化块，如果一个类里定义了两个普通初始化块;实际上初始化块是一个假象，使用javac命令编译java类后，该java类中的初始化块会消失，初始化块中代码被还原到每个构造器中，且位于构造器所有代码的前面;当JVM第一次主动使用某个类时，系统会在类准备阶段为该类的所有静态成员变量分配内存;java引用变量有两个类型：一个是编译时类型，一个是运行时类型；编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给变量的对象决定，如果编译时类型和运行时类型不一致，就可能出现所谓的多态;final修饰的变量不可被改变，一旦获的了初始值，该final变量的值就不能被重新赋值;如果final修饰的局部变量在定义时没有指定初始值，则可以在后面代码对final变量指定初始值，但只能一次，不能重复赋值；常量池专门用于管理在编译时被确定并被保存在已编译的.class文件中的一些数据，他包括了关于类、方法、接口中的常量还包括字符串常量；常量池保证相同的字符串直接量只有一个不会产生多个副本;局部变量定义后，必须经过显式初始化后才能使用，系统不会为局部变量执行初始化，这就意味着定义局部变量后，系统并没有为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存在这块内存中;
