### 线程的生命周期
+ 当线程被创建并启动以后，它即不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，他要经过`新建new、就绪runnable，运行running、阻塞blocked、和死亡dead`5个状态；
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-5.jpg) 

#### 新建和就绪状态
+ 当程序使用`new`关键字创建了一个线程之后，该线程就处于`新建状态`，此时它和其他的java对象一样，仅仅是由java虚拟机为其分配内存，并初始化其成员变量，此时的线程对象没有体现出任何线程的动态特征，程序也不会执行线程的线程执行体；当线程对象调用了`start()`方法之后，该线程处于`就绪状态`，java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了，至于该线程何时开始运行，取决于JVM里线程调度器的调度；如果希望调用子线程的start方法后子线程立即开始运行，程序可以使用`Thread.sleep(1)`；来让当前运行的线程睡眠1毫秒，1毫秒足够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始运行；
#### 运行和阻塞状态
+ 如果处于`就绪状态`的线程获得了CPU，开始执行`run方法`的线程执行体，则该线程处于`运行状态`，如果计算机只有一个CPU，那么在任何时刻只有一个线程处于运行状态，当然，如果在一个多处理器的机器上，就会有多个线程并行执行；所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统当中，只有当一个线程调用了它的`sleep()`方法或`yield()`方法后才会放弃所占用的资源，也就是`必须由该线程主动放弃所占用的资源`；

|当发生如下情况时，线程将会进入阻塞状态|
|------|
|线程调用sleep方法主动放弃所占用的处理器资源|
|线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞|
|线程试图获得一个同步监视器，但该监视器正被其他线程所持有|
|线程在等待某个通知notify|
|程序调用了线程的suspend()方法将该线程挂起，但这个方法容易造成死锁，应该尽量避免使用该方法|

+ 当前正在执行的线程被阻塞之后，其他线程就可以获得执行机会，`被阻塞的线程会在合适的时候重新进入就绪状态`；

|针对上面的几种情况，当发生如下特定的情况时可以解除上面的阻塞，让该线程重新进入就绪状态|
|------|
|调用sleep方法的线程经过了指定时间|
|线程调用的阻塞式IO方法已经返回|
|线程成功获得了试图取得的同步监视器|
|线程正在等待某个通知时，其他线程发出了一个通知|
|处于挂起状态的线程被调用了resume()恢复方法|

##### 线程状态转换图
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-6.jpg) 

#### 线程死亡

|线程会以如下三种方式结束，结束后就处于死亡状态|
|------|
|run方法或call方法执行完成，线程正常结束|
|线程抛出一个未捕获的Exception或Error|
|直接调用该线程的stop()方法来结束该线程，这种方法容易导致死锁，不推荐使用|

+ `当主线程结束时，其他线程不受任何影响，并不会随之结束`，一旦子线程启动起来后，他就拥有和主线程相同的地位，它不会受主线程的影响；为了测试某个线程是否已经死亡，可以调用该线程对象的`isAlive()方法，当线程处于就绪、运行、阻塞三种状态时，该方法返回true，当线程处于新建、死亡状态时，该方法将返回false`；`不要试图对一个已经死亡的线程调用start方法使它重新启动，死亡就是死亡`，该线程将不可再次作为线程执行；试图将已死亡的线程调用start方法来启动该线程，将引发IllegalThreadStateException异常，这表明处于死亡状态的线程无法再次运行了；不要对处于死亡状态的线程调用start方法，程序只能对新建状态的线程调用start方法，对新建状态的线程两次调用start方法也是错误的，这都会引发IllegalThreadStateException异常；
