### Checked异常和Runtime异常体系
+ java的异常分为两大类：Checked异常和Runtime异常（运行时异常），所有的RuntimeException类及其子类的实例被称为Runtime异常，不是RuntimeException类及其子类的异常实例则被称为Checked异常；如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译；对于Checked异常的处理方式有如下两种：一、当前方法明确知道如何处理该异常，程序应该使用try...catch块来捕获该异常，然后在对应的catch块中修复该异常；二、当前方法不知道如何处理这种异常，应该在定义该方法时声明抛出该异常；Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try...catch块来实现；
#### 使用throws声明抛出异常
+ 使用throws声明抛出异常的思路是：当前方法不知道如何处理这种类型的异常，该异常应该由上一级调用者处理，如果main方法也不知道如何处理这种类型的异常，也可以使用throws声明抛出异常，该异常将交给JVM处理，JVM对异常的处理方法是：打印异常的跟踪栈信息，并终止程序运行，这就是前面程序在遇到异常后自动结束的原因；throws声明抛出只能在方法签名中使用，throws可以声明抛出多个异常类，多个异常类之间以逗号隔开，throws声明抛出的语法格式为：
```
public void method() throws Exception1 , Exception2{

}
```
+ 一旦使用throws语句声明抛出该异常，程序就无须使用try...catch块来捕获该异常了；如果某段代码中调用了一个带throws声明的方法，该方法声明抛出一个Checked异常，则表明该方法希望她的调用者来处理该异常，也就是说，调用该方法时要么放在try块中显式捕获该异常，要么放在另一个带throws声明抛出的方法中；由此可见，使用Checked异常至少存在两个不便之处：一、对于程序中的Checked异常，java要求必须显式捕获并处理该异常，或者显式声明抛出该异常，这样就增加了编程复杂度；二、如果在方法中显式声明抛出Checked异常，将会导致方法签名与异常耦合，如果该方法是重写父类的方法，则该方法抛出的异常还会受到被重写方法所抛出异常的限制；在大部分时候推荐使用Runtime异常，而不使用Checked异常；使用Runtime异常将更加简洁；
