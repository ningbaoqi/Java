### 正则表达式
+ String提供了很多的特殊的方法为了正则表达式；

|方法|说明|
|------|------|
|boolean matches(String str)|判断该字符串是否匹配指定的正则表达式|
|String replaceAll(String str , String relpacement)|将该字符串中所有匹配str的子字符串替换成replacement|
|String replaceFirst(String str , String replacement)|将字符串中第一个匹配str的子字符串替换成replacement|
|String[] split(String str)|以str为分隔符，把该字符串分隔成多个子字符串|

### 创建正则表达式
#### 一、正则表达式所支持的合法字符

|字符|说明|
|------|-------|
|x|字符x(x可以代表任何合法字符)|
|\0mnn|八进制0mnn所表示的字符|
|\xhh|十六进制0xhh所表示的字符|
|\uhhhh|十六进制0xhhhh所表示的Unicode字符|
|\t|制表符|
|\n|换行符|
|\r|回车符|
|\f|换页符|
|\a|报警符|
|\e|escape符|
|\cx|x对应的控制符如：\cM 匹配Ctrl-M;x必须是A~Z、a~z之一|

#### 二、正则表达式支持的特殊字符

|特殊字符|说明|
|------|------|
|$|匹配一行的结尾，要匹配$字符本身使用\$|
|^|匹配一行的开头，要匹配^字符本身使用\^|
|()|标记子表达式的开始和结尾位置，要匹配这些字符使用\( \)|
|[]|用于确定中括号表达式的开始和结束位置，要匹配这些字符使用\[ \]|
|{}|用于标记前面子表达式的出现频率，要匹配这些字符使用\{ \}|
|*|出现0次或多次，要匹配这个字符使用\*|
|+|出现一次或多次，要匹配这个字符使用\+|
|？|出现0次或1次，要匹配这个字符使用\?|
|.|匹配除换行符之外的任何单个字符，要匹配这个字符使用\.|
|`\`|用于转义下一个字符，或制定八进制或十六进制字符，要匹配这个字符使用`\\`|
|\||指定两项之间选择任意一项，匹配这个字符使用同理|

```
"\u0041\\\\"匹配A\
"\u0061\t"匹配a制表符
"\\?\\["匹配?[
//因为java字符串中反斜杠本身需要转义，因此两个反斜杠\\实际上相当于一个
```
#### 三、预定义字符

|预定义字符|说明|
|------|------|
|.|可以匹配任意字符|
|\d|匹配0~9的所有数字|
|\D|匹配非数字|
|\s|匹配所以空白字符如：制表符、回车符、空格、换页、换行等|
|\S|匹配所有非空白字符|
|\w|匹配所有单词字符如:0~9、26个英文字母，下划线_|
|\W|匹配所有非单词字符|

#### 四、方括号表达式

|方括号表达式|说明|
|------|------|
|表示枚举|例如[abc]，表示a、b、c其中任意一个字符|
|表示返回-|如[a-f]表示a~f范围内的任意字符，[a-cx-z]表示a~c，x~z范围内的任意字符|
|表示求否：^|如[^abc]表示非a、b、c的任意字符|
|表示与运算&&|如[a-z&&[def]]求a~z和[def]的交集，就是d、e、f|
|表示并运算|如：[a-d[m-p]] 表示[a-dm-p]|

#### 五、边界匹配符

|边界匹配符|说明|
|------|------|
|^|行的开头|
|$|行的结尾|
|\b|单词的边界|
|\B|非单词的边界|
|\A|输入的开头|
|\G|前一个匹配的结尾|
|\Z|输入的结尾，仅用于最后的结束符|
|\z|输入的结尾|

#### 六、三种模式的数量表示符

|贪婪模式|勉强模式|占用模式|说明|
|------|------|------|------|
|X?|X??|X?+|X表达式出现0次或1次|
|X*|X*?|X*+|X表达式出现0次或多次|
|X+|X+?|X++|X表达式出现一次或多次|
|X{n}|X{n}?|X{n}+|X表达式出现n次|
|X{n,}|X{n,}?|X{n,}+|X表达式出现最少n次|
|X{n,m}|X{n,m}?|X{n,m}+|X表达式出现最少n次最多m次|

### 使用正则表达式
+ 一旦定义了正则表达式，就可以使用`Pattern`和`Matcher`来使用正则表达式；Pattern对象是正则表达式编译后在内存中的表示形式，因此，正则表达式字符串必须先被编译为Pattern对象，然后在利用该Pattern对象创建对应的Matcher对象，执行匹配所涉及的状态保留在Matcher对象中，多个Matcher对象可以共享同一个Pattern对象；

```
Pattern p = Pattern.compile("a*b");
Matcher m = p.matcher("aaaaab");
boolean b = m.matches();
```
+ 上面定义的Pattern对象可以多次重复使用，如果某个正则表达式仅需使用一次，则可直接使用Pattern类的matches()静态方法，此方法自动把指定字符串编译成匿名的Pattern对象，并执行匹配；

```
boolean b = Pattern.matches("a*b" , "aaaaaaab");
```

+ 上面的语句等效于前面三行代码，但是采用这种形式每次都需要重新编译新的Pattern对象，不能重复使用，效率不高；Pattern是不可变类，可供多个并发线程安全使用；

### Matcher类提供的常用方法

|常用方法|说明|
|------|------|
|find()|返回目标字符串中是否包含与Pattern匹配的子串|
|group()|返回上一次与Pattern匹配的子串|
|start()|返回上一次与Pattern匹配的子串在目标字符串中的开始位置|
|end()|返回上一次与Pattern匹配的子串在目标字符串中的结束位置+1|
|lookingAt()|返回目标字符串前面部分与Pattern是否匹配|
|matches()|返回整个目标字符串与Pattern是否匹配|
|reset()|将现有的Matcher对象应用于一个新的字符序列|

#### 如何从大段的字符串中找出电话号码

![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-70.jpg)

+ find()方法还可以传入一个int类型的参数，带int类型的find()方法将从该int索引处向下搜索；

![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-71.jpg)

+ matches()方法要求整个字符串和Pattern完全匹配时才返回true，而lookingAt()只要字符串以Pattern开头就会返回true，reset()方法可将现有的Matcher对象应用于新的字符序列；

![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-72.jpg)
![image](https://github.com/ningbaoqi/Java/blob/master/gif/pic-73.jpg)
